#!/usr/bin/env python
"""
Heimdallr: Watchman of the Gods

This script is meant to be used as an AuthorizedKeysCommand in your SSH daemon config, allowing you
to read public keys from a variety of configurable sources.

"""

import configparser
import requests
import json
import os
import sqlite3
from sys import argv, stderr, stdout


class Cache:
    """Simple sqlite3 backed cache"""

    def __init__(self, dbpath='/tmp/heimdallr.db'):
        if not os.path.exists(dbpath):
            self.initialize(dbpath)
        self.conn = sqlite3.connect(dbpath)

    @staticmethod
    def initialize(dbpath):
        "Create necessary sqlite3 tables"
        conn = sqlite3.connect(dbpath)
        cur = conn.cursor()
        cur.execute('''CREATE TABLE cache (key text primary key, etag text, value text)''')
        conn.close()

    def get(self, key):
        "Get the cached etag and value dict specified by key"
        cur = self.conn.cursor()
        cur.execute("SELECT etag, value FROM cache WHERE key=?", (key,))
        result = cur.fetchone()
        if result:
            return dict(zip(['etag', 'value'], result))

    def set(self, key, etag, value):
        "Upsert etag and value specified by unique key"
        cur = self.conn.cursor()
        cur.execute(
            "INSERT OR REPLACE INTO cache (key, etag, value) VALUES (?, ?, ?)", (key, etag, value))
        self.conn.commit()
        return self


def get_userconfig_or_default(config, username, key, fallback=None):
    """Get the requested key from the specified user's config stanza or fallback to the DEFAULT"""

    userconfig = config[username] if username in config else None

    if userconfig and key in userconfig:
        return userconfig[key]
    return config['DEFAULT'].get(key, fallback)


def load_config():
    """Get the heimdallr configuration file"""
    config = configparser.ConfigParser(allow_no_value=True)
    config.read([
        os.path.abspath('heimdallr.conf'),
        '/etc/heimdallr.conf'
        ])
    return config


def get_provider_names(config):
    """Get names of all providers specified for use by the configuration file"""
    return [x.strip() for x in config['DEFAULT']['providers'].strip().split()]

def transform_key(key, template, user):
    """Parse a key entry and transform it by a provided template.

    A single key is split up into 4 separate keywords: 'options', 'type', 'key', and 'note'.
    The 'options' value is used for things such as 'command=""' or no-pty.
    The 'type' value is the key format, such as 'ssh-rsa'.
    The 'key' value is the actual key data.
    The 'comment' value is the optional key name that is sometimes appended, such as 'user@host'
    The 'user' value is the user attempting to auth

    Replacing options is sometimes helpful when working with upstream key providers such as an
    authorized_keys file which is managed by a system such as Gitlab, where `command` options are
    prepended.
    """

    parts = key.split(' ')
    keytypes = [
        'ssh-rsa',
        'ssh-dss',
        'ssh-ed25519',
        'ecdsa-sha2-nistp521',
        'ecdsa-sha2-nistp384',
        'ecdsa-sha2-nistp256'
        ]

    for keytype in keytypes:
        if keytype in parts:
            index = parts.index(keytype)
            break

    data = {}
    data['options'] = '' if index > 0 else parts[0]
    data['type'] = parts[index]
    data['key'] = parts[index + 1]
    data['comment'] = parts[-1]
    data['user'] = user

    return template.format(**data)


def provider_filename(user, userconfig, cache):
    """Flat file provider

    Helpful for reading an authorized_keys file in a non-standard location

    The path specified by a user's `filename` entry will be read.
    """

    path = userconfig.get('filename', None)

    if not path:
        return []

    path = path.format(**{'user': user})
    lines =[]

    for file_path in path.split('\n'):
        try:
            src = open(file_path, 'r')
            lines = src.readlines()
            src.close()
        except FileNotFoundError:
            err('filesystem: unable to find file "%s"' % file_path)

    return lines


def provider_github(user, userconfig, cache):
    """Github user's public key registry provider

    Github provides user's public keys through their API, this provider fetches all public keys for
    a given user account.

    """

    # You can specify an alternate username for github keys
    user = userconfig['github'] or user

    headers = {}
    cachekey = 'github/' + user
    cached = cache.get(cachekey)
    if cached:
        headers['if-none-match'] = cached['etag']

    url = 'https://api.github.com/users/%s/keys' % user
    resp = requests.get(url, headers=headers)

    if resp.ok:
        if resp.status_code == 304:
            data = cached['value']
        else:
            data = resp.text
            cache.set(cachekey, resp.headers['etag'], data)

        data = json.loads(data)
        return [x['key'] for x in data]

    return []


def provider_website(user, userconfig, cache):
    """Fetch some keys from a web resource.

    Grab keys from a website, assuming you return one per line.

    Set `website` in a user stanza to a URL to use, or set `website` in
    the DEFAULT stanza, {user} will be replaced with the authenticating user.

    It's probably wise to use https hosts and check the cert!
    """

    url = userconfig.get('website', None)
    if not url:
        return []

    url = url.format(**{'user': user})
    headers = {}
    cachekey = 'website/' + user
    cached = cache.get(cachekey)
    if cached:
        headers['if-none-match'] = cached['etag']

    resp = requests.get(url, headers=headers)

    if resp.ok:
        if resp.status_code == 304:
            data = cached['value']
        else:
            data = resp.text
        return [x.strip() for x in data.split('\n')]

    return []


def run_checks(config, providers, provider_methods, cache):
    """Perform a few error checks and run through the config."""
    # check that providers exist
    for provider in providers:
        print("checking provider '%s'" % provider)
        if provider not in provider_methods:
            err("unknown provider '%s' specified in providers list" % provider, 1)

    # verify that at least one provider is in use
    if not providers:
        err("no providers are provided", 1)

    # check all per-user configurations
    for key in config.keys():
        if key == 'DEFAULT':
            continue

        user = key
        userconfig = config[key]
        for item in userconfig.keys():
            if item in providers:
                provider_methods[item](user, userconfig, cache)

    print('OK')
    exit(0)


def err(msg, code=None):
    """Print an error message and emit an exit code if provided."""
    stderr.write(msg + '\n')
    if code:
        exit(code)

def run(provider_methods):
    """Iterate through the requested user's providers and output keys."""
    config = load_config()
    available_providers = provider_methods.keys()
    default_config = config['DEFAULT']
    cache = Cache(default_config.get('cache', '/tmp/heimdallr.db'))

    if len(argv) <= 1:
        err('error: please provide a username or --check to run tests', 1)

    if argv[1] == '--check':
        return run_checks(config, available_providers, provider_methods, cache)

    user = argv[1]

    user_config = config[user] if user in config else None

    if user_config:
        for provider in available_providers:
            if provider in user_config:
                keys = provider_methods[provider](user, user_config, cache)
                template_name = provider + '_template'
                template = user_config.get(template_name, default_config.get(template_name, None))

                if template:
                    keys = [transform_key(key, template, user) for key in keys]

                for key in keys:
                    stdout.write(key + '\n')

    else:
        for provider in available_providers:
            if provider in default_config:
                keys = provider_methods[provider](user, default_config, cache)
                template_name = provider + '_template'
                template = default_config.get(template_name, None)

                if template:
                    keys = [transform_key(key, template, user) for key in keys]

                for key in keys:
                    stdout.write(key + '\n')
    exit(0)




def runold(provider_methods):
    """Iterate through providers (in order) and output keys."""
    config = load_config()
    providers = get_provider_names(config)
    cache = Cache(config['DEFAULT'].get('cache', '/tmp/heimdallr.db'))

    if len(argv) <= 1:
        err('error: please provide a username or --check to run tests', 1)

    if argv[1] == '--check':
        return run_checks(config, providers, provider_methods, cache)

    user = argv[1]

    userconfig = config[user] if user in config else None

    for provider in providers:
        keys = provider_methods[provider](user, userconfig, cache)

        template = get_userconfig_or_default(config, user, provider + '_template', None)

        if template:
            keys = [transform_key(key, template, user) for key in keys]

        stdout.write('\n'.join(keys) + '\n')


if __name__ == '__main__':
    PROVIDER_METHODS = {
        'github': provider_github,
        'website': provider_website,
        'filename': provider_filename,
        }

    run(PROVIDER_METHODS)

# vim:cc=100:tw=100
